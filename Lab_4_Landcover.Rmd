---
title: "Lab_4_Landcover"
output: html_document
date: "2024-02-05"
---
```{r, warning=F, error=F, message=F}
rm(list=ls())
require(Voss)
require(tidyverse)
require(terra)
require(FedData)
require(sf)
require(tidyterra)
require(landscapemetrics)
```

```{r}
studyArea = st_read('/vsicurl/https://github.com/ValenteJJ/SpatialEcology/raw/main/Week4/studyArea.shp')
nlcd = get_nlcd(studyArea, label='AlLandscape', year=2011)

# values(nlcd) = as.character(values(nlcd))

plot(nlcd)
```

```{r}

nlcdSimple = nlcd
nlcdSimple[nlcdSimple==11] = 1 #Wet areas are a 1 now
nlcdSimple[nlcdSimple %in% c(21, 22, 23, 24)] = 2 #All developed areas are 2
nlcdSimple[nlcdSimple %in% c(31, 52)] = 3 #Barren land and shrub/scrub are 3
nlcdSimple[nlcdSimple %in% c(41,42,43)] = 4 #All forest types are 4
nlcdSimple[nlcdSimple == 71] = 5 #Grassland is 5
nlcdSimple[nlcdSimple %in% c(81,82)] = 6 #And agriculture is 6

#Give these numbers category names
tmp = data.frame('ID' = c(1, 2, 3, 4, 5, 6),
                 'category' = c('wetland', 'developed', 'open', 'forest', 'grassland', 'agriculture'))
nlcdSimple = categories(nlcdSimple, value=tmp)

#And plot the new raster
ggplot(nlcdSimple, aes(x=x, y=y, fill=category)) +
  geom_raster()+
  scale_fill_manual(values=c('blue', 'black', 'gray', 'darkolivegreen', 'orange', 'yellow'))
```

```{r}
res(nlcdSimple)
ext(nlcdSimple)
levels(nlcdSimple)
```

```{r}

forest = nlcdSimple %>% 
  setValues(NA)
  
forest[nlcdSimple ==4] = 1

plot(forest)

```

```{r}
forestPatchId = patches(forest, directions=8, zeroAsNA=T, allowGaps=F)

plot(forestPatchId)
```


## Challenge 1 (4 points)

**The landscapemetrics package has functions for calculating 12 patch-level metrics. Calculate all 12 of these for every forest patch in our nlcdSimple raster (using the 8-direction rule). This will result in 12 unique values associated with each forest patch. Use the chart.Correlation() function from the PerformanceAnalytics package to examine the correlation among all 12 of these variables.** 

```{r}
#First metric - total area
patchArea = lsm_p_area(forest, directions=8)

patchArea

#Second metric - core area
patchCore = lsm_p_core(forest, directions=8)

patchCore

#Third metric - core area index
patchCai = lsm_p_cai(forest, directions=8)

patchCai

#Fourth metric - euclidean nearest neighbor distance
patchEnn = lsm_p_enn(forest, directions=8)

patchEnn

#Fifth metric - contiguity index
patchCont = lsm_p_contig(forest, directions=8)

patchCont

#Sixth metric - perimeter 
patchPerim = lsm_p_perim(forest, directions=8)

patchPerim

#Seventh metric - perimeter to area ratio 
patchPara = lsm_p_para(forest, directions=8)

patchPara

#Eighth metric - related circumscribing circle 

patchCircle = lsm_p_circle(forest, directions=8)

patchCircle

#Ninth metric - fractal dimension index
 patchFrac = lsm_p_frac(forest, directions=8)
 
 patchFrac
 
#Tenth metric - radius of gyration  
  patchGy = lsm_p_gyrate(forest, directions=8)
  
  patchGy
  
# Eleventh metric - shape index
   patchShp = lsm_p_shape(forest, directions=8)
   
   patchShp 
   
#Twelth metric - number of core areas
   patchNcore = lsm_p_ncore(forest, directions=8)
   
   patchNcore
   

```
PerformanceAnalytics::chart.Correlation( 
  R, 
  histogram = TRUE,
  method = c("patchArea", "patchCai", "patchCore","patchEnn", "patchCont", "patchPerim", "patchPara", "patchCircle", "patchFrac", "patchGy", "patchShp", "patchNcore" ))


```{r}
forest%>% 
  as.data.frame() %>% 
  select(all_of(patchArea), patchCai, patchCircle, patchCont, patchCore, patchEnn, patchFrac, patchGy, patchNcore, patchPara, patchPerim, patchShp)) %>% 
  PerformanceAnalytics::chart.Correlation(histogram=F)
```
*What patterns do you notice, and what do they tell you about the uniqueness or redundancy of the patch-level metrics you calculated?*


## Challenge 2 (4 points)

**In our lab, we used the 8-direction or "queen" rule to delineate patches. Using the nlcdSimple raster we created, explore the differences in patch characteristics if you were to use the 4-direction or "rook" rule for delineating patches. Calculate the following class-level metrics for forest cover for both the queen and rook patch delineation rules: number of patches, mean patch size, standard deviation in patch size, nearest-neighbor distance, and total edge length.** 

```{r}
#The functions annoyingly summarize by class instead of category, so we have to merge the category values back in after the summary.

classCats = data.frame('class' = c(1, 2, 3, 4, 5, 6),
                 'category' = c('wetland', 'developed', 'open', 'forest', 'grassland', 'agriculture'))


#number of patches
patchNQ = lsm_c_np(nlcdSimple, directions=8)%>% 
  left_join(classCats, by='class')

patchNQ

patchNR = lsm_c_np(nlcdSimple, directions=4)%>% 
  left_join(classCats, by='class')

patchNR

#mean patch size
patchAreaMQ = lsm_c_area_mn(nlcdSimple, directions=8)%>% 
  left_join(classCats, by='class')

patchAreaMQ

patchAreaMR = lsm_c_area_mn(nlcdSimple, directions=4)%>% 
  left_join(classCats, by='class')

patchAreaMR

#standard deviation in patch size
patchSDQ = lsm_c_area_sd(nlcdSimple, directions=8)%>% 
  left_join(classCats, by='class')

patchSDQ

patchSDR = lsm_c_area_sd(nlcdSimple, directions=4)%>% 
  left_join(classCats, by='class')

patchSDR

#nearest-neighbor distance
patchEnnQ = lsm_c_enn_cv(nlcdSimple, directions=8)%>% 
  left_join(classCats, by='class')

patchEnnQ

patchEnnR = lsm_c_enn_cv(nlcdSimple, directions=4)%>% 
  left_join(classCats, by='class')

patchEnnR

#total edge length
patchTeQ = lsm_c_te(nlcdSimple, directions=8)%>% 
  left_join(classCats, by='class')

patchTeQ

patchTeR = lsm_c_te(nlcdSimple, directions=4)%>% 
  left_join(classCats, by='class')

patchTeR

```
*What patterns do you notice? When might it be appropriate to use one rule vs. the other?*
Applying the queen or rook rule to delineate patches can affect measurements depending on what you are measuring. When looking at the class level metrics for number of patches, mean patch size, standard deviation in patch size, nearest-neighbor distance, and total edge length, only total edge length did not show any difference between using the queen and rook rules. Nearest-neighbor distance and number of patches usually increases when using the rook rule compared to using the queen rule. Standard deviation in patch size and mean patch size usually decreases when using the rook rule compared to using the queen rule. 
I think that using the rook rule better applies to species with that require larger habitats, due to having larger body sizes, limited movement, or needing more area due to diet or territorial behavior, like mountain lions. The queen rule better applies to species with smaller body sizes, better movement, and/or higher population densities, like most passerines.



## Challenge 3 (4 points)


**Using the same zoomed-in study area that we used in the lab, download NLCD raster data for the years 2001 and 2019 and simplify these rasters into 6 landcover categories (wet, developed, barren, forest, grassland, and agriculture). Plot these two rasters.**

```{r}
studyArea = st_read('/vsicurl/https://github.com/ValenteJJ/SpatialEcology/raw/main/Week4/studyArea.shp')
nlcd2001 = get_nlcd(studyArea, label='Landscape01', year=2001)

values(nlcd2001) = as.character(values(nlcd2001))

plot(nlcd2001)

```

```{r}
nlcdSimple1 = nlcd2001
nlcdSimple1[nlcdSimple1==11] = 1 #Wet areas are a 1 now
nlcdSimple1[nlcdSimple1 %in% c(21, 22, 23, 24)] = 2 #All developed areas are 2
nlcdSimple1[nlcdSimple1 %in% c(31, 52)] = 3 #Barren land and shrub/scrub are 3
nlcdSimple1[nlcdSimple1 %in% c(41,42,43)] = 4 #All forest types are 4
nlcdSimple1[nlcdSimple1 == 71] = 5 #Grassland is 5
nlcdSimple1[nlcdSimple1 %in% c(81,82)] = 6 #And agriculture is 6

#Give these numbers category names
tmp = data.frame('ID' = c(1, 2, 3, 4, 5, 6),
                 'category' = c('wetland', 'developed', 'open', 'forest', 'grassland', 'agriculture'))
nlcdSimple1 = categories(nlcdSimple1, value=tmp)

#And plot the new raster
ggplot(nlcdSimple1, aes(x=x, y=y, fill=category)) +
  geom_raster()+
  scale_fill_manual(values=c('blue', 'black', 'gray', 'darkolivegreen', 'orange', 'yellow'))
```


```{r}
studyArea = st_read('/vsicurl/https://github.com/ValenteJJ/SpatialEcology/raw/main/Week4/studyArea.shp')
nlcd2019 = get_nlcd(studyArea, label='Landscape19', year=2019)

values(nlcd2019) = as.character(values(nlcd2019))

plot(nlcd2019)
```

```{r}
nlcdSimple2 = nlcd2019
nlcdSimple2[nlcdSimple2==11] = 1 #Wet areas are a 1 now
nlcdSimple2[nlcdSimple2 %in% c(21, 22, 23, 24)] = 2 #All developed areas are 2
nlcdSimple2[nlcdSimple2 %in% c(31, 52)] = 3 #Barren land and shrub/scrub are 3
nlcdSimple2[nlcdSimple2 %in% c(41,42,43)] = 4 #All forest types are 4
nlcdSimple2[nlcdSimple2 == 71] = 5 #Grassland is 5
nlcdSimple2[nlcdSimple2 %in% c(81,82)] = 6 #And agriculture is 6

#Give these numbers category names
tmp = data.frame('ID' = c(1, 2, 3, 4, 5, 6),
                 'category' = c('wetland', 'developed', 'open', 'forest', 'grassland', 'agriculture'))
nlcdSimple2 = categories(nlcdSimple2, value=tmp)

#And plot the new raster
ggplot(nlcdSimple2, aes(x=x, y=y, fill=category)) +
  geom_raster()+
  scale_fill_manual(values=c('blue', 'black', 'gray', 'darkolivegreen', 'orange', 'yellow'))
```
**What are some of the initial changes you notice between 2001 and 2019?**


**Quantify this at the class level by calculating and reporting the changes in (1) the total amount of each land cover type (2) mean patch size for each land cover type, and (3) mean nearest neighbor distance for each cover type between the years 2011 and 2019.** 
```{r}
#Total amount of each landcover type
patchA2011 = lsm_c_ca(nlcdSimple, directions=8)%>% 
  left_join(classCats, by='class')

patchA2011

patchA2019 = lsm_c_ca(nlcdSimple2, directions=8)%>% 
  left_join(classCats, by='class')

patchA2019

#mean patch size for each landcover type
patchArea2011 = lsm_c_area_mn(nlcdSimple, directions=8)%>% 
  left_join(classCats, by='class')

patchArea2011

patchArea2019 = lsm_c_area_mn(nlcdSimple2, directions=8)%>% 
  left_join(classCats, by='class')

patchArea2019

#mean nearest neighbor distance
patchE2011 = lsm_c_enn_mn(nlcdSimple, directions=8)%>% 
  left_join(classCats, by='class')

patchE2011

patchE2019 = lsm_c_enn_mn(nlcdSimple2, directions=8)%>% 
  left_join(classCats, by='class')

patchE2019

```
*Give a short description of how you interpret the changes in these values.*



**Quantify these changes at the landscape level by calculating and reporting on changes in the (1) Shannon diversity and (2) Shannon evenness of the landscapes at the different time points.**
```{r}
#2001 
lsm_l_shdi(nlcdSimple1)

lsm_l_shei(nlcdSimple1)

#2011
lsm_l_shdi(nlcdSimple)

lsm_l_shei(nlcdSimple)

#2019
lsm_l_shdi(nlcdSimple2)

lsm_l_shei(nlcdSimple2)

```
*Give a short description of how you interpret the changes in these values.*


## Challenge 4 (4 points)

**Use the voss2d() function to simulate a surface where g = 7 and H = 0.5. From that, create 9 'landscapes' with 10%, 20%, 30%, ..., 90% threshold values. The '1' values here can represent anything your imagination comes up with. It could be forest cover, cover of some other land cover type, bodies of water, temperatures above a threshold, etc. I suggest you set the seed for your simulation value so that you get the same outcome each time you run the code. Plot these landscapes.**

```{r}
set.seed(23)
vossModel = voss2d(g=7, H=0.5)
vossModel = rast(vossModel$z)

plot(vossModel)


```



```{r}
# 90% cover
threshold90 = quantile(as.matrix(vossModel), prob=0.9)
voss90 = ifel(vossModel > threshold90, 0, 1)
plot(voss90)

# 80% cover
threshold80 = quantile(as.matrix(vossModel), prob=0.8)
voss80 = ifel(vossModel > threshold80, 0, 1)
plot(voss80)

# 70% cover
threshold70 = quantile(as.matrix(vossModel), prob=0.7)
voss70 = ifel(vossModel > threshold70, 0, 1)
plot(voss70)

# 60% cover
threshold60 = quantile(as.matrix(vossModel), prob=0.6)
voss60 = ifel(vossModel > threshold60, 0, 1)
plot(voss60)

# 50% cover
threshold50 = quantile(as.matrix(vossModel), prob=0.5)
voss50 = ifel(vossModel > threshold50, 0, 1)
plot(voss50)

# 40% cover
threshold40 = quantile(as.matrix(vossModel), prob=0.4)
voss40 = ifel(vossModel > threshold40, 0, 1)
plot(voss40)

# 30% cover
threshold30 = quantile(as.matrix(vossModel), prob=0.3)
voss30 = ifel(vossModel > threshold30, 0, 1)
plot(voss30)

# 20% cover
threshold20 = quantile(as.matrix(vossModel), prob=0.2)
voss20 = ifel(vossModel > threshold80, 0, 1)
plot(voss20)

# 10% cover
threshold10 = quantile(as.matrix(vossModel), prob=0.1)
voss10 = ifel(vossModel > threshold10, 0, 1)
plot(voss10)

```
*comment on what patterns you see changing as the value increases from a 10% cover to 90% cover*




